# kingshard的地址和端口
addr: 0.0.0.0:9696

# 连接kingshard的用户名和密码的用户列表
user_list:
  - user: kingshard
    password: kingshard
#kingshard的web API 端口
web_addr: 0.0.0.0:9797
#调用API的用户名和密码
web_user: admin
web_password: admin

# log级别，[debug|info|warn|error],默认是error
log_level: debug
# 打开SQL日志，设置为on;关闭SQL日志，设置为off
log_sql: on
#如果设置了该项，则只输出SQL执行时间超过slow_log_time(单位毫秒)的SQL日志，不设置则输出全部SQL日志
slow_log_time: 100
#日志文件路径，如果不配置则会输出到终端。
log_path: logs
# sql黑名单文件路径
# 所有在该文件中的sql都会被kingshard拒绝转发
#blacklist_sql_file: /Users/flike/blacklist
# 只允许下面的IP列表连接kingshard，如果不配置则对连接kingshard的IP不做限制。
allow_ips: 127.0.0.1
# kingshard使用的字符集，如果不设置该选项，则kingshard使用utf8作为默认字符集
proxy_charset: utf8mb4

# 一个node节点表示mysql集群的一个数据分片，包括一主多从（可以不配置从库）
groups:
  - name: shard1 # 分片名称
    nodes:
      - name: node1 #node节点名字
        # 连接池中最大空闲连接数，也就是最多与后端DB建立max_conns_limit个连接
        max_conns_limit: 16
        # kingshard连接该node中mysql的用户名和密码，master和slave的用户名和密码必须一致
        user: root
        password: Huawei@123
        # 节点角色
        # MASTER：主库；
        # REPLICA：备库，可提升为主；
        # READONLY：从库，提供只读请求，以及运维任务，包括：备份、dump数据、分析型任务执行；
        # BACKUP：备份实例，提供备份快找；
        # ANALYSIS：分析型实例，专门进行计算任务SQL的执行
        # DRAINED：下线状态的实例，比如进行重分片操作的实例；
        role: Master
        # 节点地址和端口
        addr: 127.0.0.1:3306
        weight: 3
        #kingshard在300秒内都连接不上mysql，kingshard则会下线该mysql
        down_after_noalive: 300
  - name: shard2 # 分片名称
    nodes:
      - name: node1 #node节点名字
        # 连接池中最大空闲连接数，也就是最多与后端DB建立max_conns_limit个连接
        max_conns_limit: 16
        # kingshard连接该node中mysql的用户名和密码，master和slave的用户名和密码必须一致
        user: root
        password: Huawei@123
        # 节点角色
        # MASTER：主库；
        # REPLICA：备库，可提升为主；
        # READONLY：从库，提供只读请求，以及运维任务，包括：备份、dump数据、分析型任务执行；
        # BACKUP：备份实例，提供备份快找；
        # ANALYSIS：分析型实例，专门进行计算任务SQL的执行
        # DRAINED：下线状态的实例，比如进行重分片操作的实例；
        role: Master
        # 节点地址和端口
        addr: 127.0.0.1:3306
        weight: 3
        #kingshard在300秒内都连接不上mysql，kingshard则会下线该mysql
        down_after_noalive: 300
  - name: shard3 # 分片名称
    nodes:
      - name: node1 #node节点名字
        # 连接池中最大空闲连接数，也就是最多与后端DB建立max_conns_limit个连接
        max_conns_limit: 16
        # kingshard连接该node中mysql的用户名和密码，master和slave的用户名和密码必须一致
        user: root
        password: Huawei@123
        # 节点角色
        # MASTER：主库；
        # REPLICA：备库，可提升为主；
        # READONLY：从库，提供只读请求，以及运维任务，包括：备份、dump数据、分析型任务执行；
        # BACKUP：备份实例，提供备份快找；
        # ANALYSIS：分析型实例，专门进行计算任务SQL的执行
        # DRAINED：下线状态的实例，比如进行重分片操作的实例；
        role: Master
        # 节点地址和端口
        addr: 127.0.0.1:3306
        weight: 3
        #kingshard在300秒内都连接不上mysql，kingshard则会下线该mysql
        down_after_noalive: 300

# 各用户的分表规则
schema_list:
  - #schema的所属用户名
    user: kingshard
    #分表分布的node名字
    nodes: [ node1,node2 ]
    #所有未分表的SQL，都会发往默认node。
    default: node1
    shard:
      - #分表使用的db
        db: kingshard
        #分表名字
        table: test_shard_hash
        #分表字段
        key: id
        #分表分布的node
        nodes: [ node1, node2 ]
        #分表类型
        type: hash
        #子表个数分布，表示node1有4个子表，node2有4个子表。
        locations: [ 4,4 ]
      - #分表使用的db
        db: kingshard
        #分表名字
        table: test_shard_range
        #分表字段
        key: id
        #分表类型
        type: range
        #分表分布的node
        nodes: [ node1, node2 ]
        #子表个数分布，表示node1有4个子表，
        #node2有4个子表。
        locations: [ 4,4 ]
        #表示每个子表包含的最大记录数，也就是说每个子表最多包好10000条记录。即子表1对应的id为[0,10000),子表2[10000,20000)....
        table_row_limit: 10000

##############################
# 路由规则配置
##############################
routing_rules:
  - # 匹配类型，取值：
    # SQL：基于SQL语句抽象正则
    # TABLE：基于表名，多张表以逗号分隔
    # DB：基于库名，多个库以逗号分隔
    # USER：基于用户，多个用户以逗号分隔
    match_type: SQL
    # 匹配内容，根据 match_type 的不同而不同
    match_content: select * from db1.t1
    # 匹配规则后执行的动作，取值：
    # reject：拒绝请求
    # routing：路由请求
    action: routing
    # 路由目标类型，取值：
    # role：路由到具体role的节点
    # name: 路由到具体name的节点
    target_type: role
    # 路由目标的名称
    # 1）若 target_type = role，可取值为：
    # MASTER：主节点；
    # REPLICA：备节点，可提升为主，可承担读流量；
    # READONLY：只读节点，提供只读请求，以及运维任务，包括：备份、dump数据、分析型任务执行；
    # ANALYSIS：分析型节点，专门进行计算任务SQL的执行；
    # 2）若 target_type = name，则配置为node的name：
    target_name: ANALYSIS
  - # 匹配类型，取值：
    # SQL：基于SQL语句抽象正则
    # TABLE：基于表名，多张表以逗号分隔
    # DB：基于库名，多个库以逗号分隔
    # USER：基于用户，多个用户以逗号分隔
    match_type: TABLE
    # 匹配内容，根据 match_type 的不同而不同
    match_content: t1,t2,t3
    # 匹配规则后执行的动作，取值：
    # reject：拒绝请求
    # routing：路由请求
    action: routing
    # 路由目标类型，取值：
    # role：路由到具体role的节点
    # name: 路由到具体name的节点
    target_type: role
    # 路由目标的名称
    # 1）若 target_type = role，可取值为：
    # MASTER：主节点；
    # REPLICA：备节点，可提升为主，可承担读流量；
    # READONLY：只读节点，提供只读请求，以及运维任务，包括：备份、dump数据、分析型任务执行；
    # ANALYSIS：分析型节点，专门进行计算任务SQL的执行；
    # 2）若 target_type = name，则配置为node的name：
    target_name: MASTER